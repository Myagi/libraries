{"version":3,"file":"fraql.min.js","sources":["../node_modules/xtend/immutable.js","../src/transform.js","../src/fraql.js"],"sourcesContent":["module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","import { print, Source } from 'graphql/language'\nimport extend from 'xtend'\n\nfunction inlineSpreadFragments(fragmentDefinitions, definition) {\n  if (definition.kind === 'FragmentSpread') {\n    return fragmentDefinitions.find(\n      ({ name }) => name.value === definition.name.value,\n    )\n  }\n  if (!definition.selectionSet) {\n    return definition\n  }\n\n  definition.selectionSet = extend(definition.selectionSet, {\n    selections: definition.selectionSet.selections.map(selection =>\n      inlineSpreadFragments(fragmentDefinitions, selection),\n    ),\n  })\n\n  return definition\n}\n\nexport function toInlineFragment(doc) {\n  let definitions = doc.definitions.map(definition => {\n    if (definition.kind !== 'FragmentDefinition') {\n      throw new Error(\n        `fraql: toInlineFragment must be called on a document that only contains fragments`,\n      )\n    }\n\n    return {\n      kind: 'InlineFragment',\n      name: definition.name,\n      directives: definition.directives,\n      selectionSet: definition.selectionSet,\n      typeCondition: definition.typeCondition,\n    }\n  })\n\n  definitions = definitions.map(definition =>\n    inlineSpreadFragments(definitions, definition),\n  )\n\n  const definition = definitions[0]\n\n  if (!definition) {\n    throw new Error('Unable to find a fragment definition')\n  }\n\n  const newDoc = extend(doc, {\n    originalDocument: doc,\n    definitions: [definition],\n  })\n\n  newDoc.loc = extend(doc.loc, {\n    source: new Source(print(newDoc)),\n  })\n\n  return newDoc\n}\n","import gql, { disableFragmentWarnings } from 'graphql-tag'\nimport { toInlineFragment } from './transform'\n\nconst fraql = (...args) => {\n  disableFragmentWarnings()\n\n  const doc = gql(...args)\n\n  if (doc.definitions.every(({ kind }) => kind === 'FragmentDefinition')) {\n    return toInlineFragment(doc)\n  }\n\n  return doc\n}\n\nexport default fraql\n"],"names":["target","i","arguments","length","source","key","hasOwnProperty","call","Object","prototype","toInlineFragment","doc","definitions","map","definition","kind","Error","name","directives","selectionSet","typeCondition","inlineSpreadFragments","fragmentDefinitions","find","value","extend","selections","selection","newDoc","loc","Source","print","gql","every"],"mappings":"0UAIA,mBACQA,KAEKC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,KACnCG,EAASF,UAAUD,OAElB,IAAII,KAAOD,EACRE,EAAeC,KAAKH,EAAQC,OACrBA,GAAOD,EAAOC,WAK1BL,GAfPM,EAAiBE,OAAOC,UAAUH,eCoB/B,SAASI,EAAiBC,OAC3BC,EAAcD,EAAIC,YAAYC,IAAI,eACZ,uBAApBC,EAAWC,WACP,IAAIC,uGAMJ,sBACAF,EAAWG,gBACLH,EAAWI,wBACTJ,EAAWK,2BACVL,EAAWM,iBAQxBN,KAJQF,EAAYC,IAAI,mBApChC,SAASQ,EAAsBC,EAAqBR,SAC1B,mBAApBA,EAAWC,KACNO,EAAoBC,KACzB,qBAAGN,KAAgBO,QAAUV,EAAWG,KAAKO,QAG5CV,EAAWK,gBAILA,aAAeM,EAAOX,EAAWK,yBAC9BL,EAAWK,aAAaO,WAAWb,IAAI,mBACjDQ,EAAsBC,EAAqBK,OAIxCb,GATEA,EA8BPO,CAAsBT,EAAaE,MAGN,OAE1BA,QACG,IAAIE,MAAM,4CAGZY,EAASH,EAAOd,oBACFA,eACJG,cAGTe,IAAMJ,EAAOd,EAAIkB,YACd,IAAIC,SAAOC,QAAMH,MAGpBA,YCvDK,2CAGNjB,EAAMqB,iCAERrB,EAAIC,YAAYqB,MAAM,kBAAuB,yBAApBlB,OACpBL,EAAiBC,GAGnBA"}